#!/usr/bin/env bash
#
# nunchux-run - Run a command with parent shell environment
#
# This script centralizes ALL environment inheritance logic. It:
# 1. Reads the env file path from tmux environment (NUNCHUX_ENV_FILE)
# 2. Filters out problematic variables (BASH*, TMUX, etc.)
# 3. Applies the environment with proper escaping
# 4. Runs the command (or just applies env if sourced)
#
# Usage:
#    nunchux-run <command> [args...]   - Run command with inherited env
#    source nunchux-run                - Just apply env (for complex scripts)
#
# The env file path is obtained automatically from tmux environment.
# If no env file is available, gracefully continues without it.

# Chuck Norris programming facts (for error screens)
CHUCK_FACTS=(
  "Chuck Norris can unit test entire applications with a single assert."
  "Chuck Norris doesn't use web frameworks. The internet obeys him."
  "Chuck Norris can delete the root folder and still boot."
  "Chuck Norris's code doesn't follow conventions. Conventions follow his code."
  "Chuck Norris can instantiate an abstract class."
  "Chuck Norris doesn't need sudo. The system always trusts him."
  "Chuck Norris can divide by zero."
  "When Chuck Norris throws an exception, nothing can catch it."
  "Chuck Norris's keyboard doesn't have a Ctrl key. He's always in control."
  "Chuck Norris can compile syntax errors."
  "Chuck Norris doesn't need garbage collection. Memory is too afraid to leak."
  "Chuck Norris can read from /dev/null."
  "Chuck Norris finished World of Warcraft."
  "Chuck Norris can write infinite loops that finish in under 2 seconds."
  "Chuck Norris's code is self-documenting. In binary."
  "Chuck Norris doesn't pair program. The code pairs with him."
  "When Chuck Norris git pushes, the remote pulls."
  "Chuck Norris can access private methods. Publicly."
  "Chuck Norris doesn't get compiler errors. The compiler gets Chuck Norris errors."
  "Chuck Norris can make a class that is both abstract and final."
)

# Get a random Chuck Norris fact
random_chuck_fact() {
  echo "${CHUCK_FACTS[$RANDOM % ${#CHUCK_FACTS[@]}]}"
}

# Apply parent environment from tmux's NUNCHUX_ENV_FILE
_nunchux_apply_env() {
  local env_file name value

  # Get env file path from tmux environment (set by keybinding)
  env_file=$(tmux show-environment NUNCHUX_ENV_FILE 2>/dev/null | cut -d= -f2)

  if [[ -z "$env_file" || ! -r "$env_file" ]]; then
    return 0 # No env file available, continue without it
  fi

  # Read and apply environment, filtering problematic variables
  while IFS='=' read -r name value; do
    # Skip empty lines
    [[ -z "$name" ]] && continue

    # Skip variables that could cause issues
    case "$name" in
    # Bash internal variables
    BASH* | SHELLOPTS | FUNCNAME | GROUPS | DIRSTACK)
      continue
      ;;
    # Process/shell state
    EUID | UID | PPID | SHELL | SHLVL | _ | PWD | OLDPWD | PATH)
      continue
      ;;
    # Tmux internal variables
    TMUX | TMUX_PANE | TERM)
      continue
      ;;
    esac

    # Export the variable
    export "$name=$value"
  done <"$env_file"
}

# Launch a command with the appropriate action
# Usage: nunchux_launch --action ACTION --name NAME --cmd CMD [OPTIONS]
#
# Options:
#   --action        popup | window | background_window | pane_right | pane_left | pane_above | pane_below
#   --name          Window/popup title
#   --cmd           Command to execute
#   --dir           Working directory (default: current pane dir)
#   --width         Popup width (default: 90%)
#   --height        Popup height (default: 90%)
#   --type          app | dirbrowser (affects behavior)
#   --on-exit       Command to run after main command (apps only)
#
# Type-specific behavior:
#   app: popup shows Chuck facts on error, window switches focus after
#   dirbrowser: no special behavior
#
# This centralizes all launch logic so modules just pass action through.
nunchux_launch() {
  local action="" name="" cmd="" dir="" width="" height="" type="" on_exit=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --action)
      action="$2"
      shift 2
      ;;
    --name)
      name="$2"
      shift 2
      ;;
    --cmd)
      cmd="$2"
      shift 2
      ;;
    --dir)
      dir="$2"
      shift 2
      ;;
    --width)
      width="$2"
      shift 2
      ;;
    --height)
      height="$2"
      shift 2
      ;;
    --type)
      type="$2"
      shift 2
      ;;
    --on-exit)
      on_exit="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  # Default dir to current pane directory
  dir="${dir:-$(tmux display-message -p '#{pane_current_path}' 2>/dev/null || pwd)}"

  # Default dimensions from global config or fallback
  width="${width:-${APP_POPUP_WIDTH:-90%}}"
  height="${height:-${APP_POPUP_HEIGHT:-90%}}"

  # Add % suffix if just a number
  [[ "$width" =~ ^[0-9]+$ ]] && width="${width}%"
  [[ "$height" =~ ^[0-9]+$ ]] && height="${height}%"

  case "$action" in
  popup)
    _nunchux_launch_popup "$name" "$cmd" "$dir" "$width" "$height" "$type" "$on_exit"
    ;;
  window)
    tmux new-window -n "$name" -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    # For apps, switch to the window
    [[ "$type" == "app" ]] && tmux select-window -t "$name" 2>/dev/null
    ;;
  background_window)
    tmux new-window -d -n "$name" -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    ;;
  pane_right)
    tmux split-window -h -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    ;;
  pane_left)
    tmux split-window -h -b -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    ;;
  pane_below)
    tmux split-window -v -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    ;;
  pane_above)
    tmux split-window -v -b -c "$dir" "$NUNCHUX_BIN_DIR/nunchux-run" bash -c "$cmd"
    ;;
  *)
    echo "nunchux_launch: unknown action '$action'" >&2
    return 1
    ;;
  esac
}

# Internal: launch popup with type-specific behavior
_nunchux_launch_popup() {
  local name="$1" cmd="$2" dir="$3" width="$4" height="$5" type="$6" on_exit="$7"
  local script="/tmp/nunchux-popup-$$"

  # Clamp dimensions to max if set
  clamp_popup_dimensions width height

  if [[ "$type" == "app" ]]; then
    # App popup: variable substitution, on_exit, error handling
    local pane_id tmp
    pane_id=$(tmux display-message -p '#{pane_id}')
    tmp="/tmp/nunchux-tmp-$$"

    # Substitute variables in cmd and on_exit
    cmd="${cmd//\{pane_id\}/$pane_id}"
    cmd="${cmd//\{tmp\}/$tmp}"
    cmd="${cmd//\{dir\}/$dir}"
    on_exit="${on_exit//\{pane_id\}/$pane_id}"
    on_exit="${on_exit//\{tmp\}/$tmp}"
    on_exit="${on_exit//\{dir\}/$dir}"

    cat >"$script" <<NUNCHUX_EOF
#!/usr/bin/env bash
source "$NUNCHUX_BIN_DIR/nunchux-run"
export PATH="$NUNCHUX_BIN_DIR:\$PATH"
cd "$dir"

# Run the command (suppress stderr, we show our own error)
$cmd 2>/dev/null
exit_code=\$?

# Run on_exit if defined
$on_exit

# If command failed, show error with Chuck Norris fact
if [[ \$exit_code -ne 0 ]]; then
    echo ""
    echo -e "\033[1;33m\$(random_chuck_fact)\033[0m"
    echo ""
    echo -e "\033[90m... but you are not Chuck Norris :)\033[0m"
    echo ""
    if [[ \$exit_code -eq 127 ]]; then
        echo -e "\033[1;31mCommand not found: $name\033[0m"
    else
        echo -e "\033[1;31m$name exited with code \$exit_code\033[0m"
    fi
    echo ""
    echo "Press any key..."
    read -n 1 -s
fi
rm -f "$script"
NUNCHUX_EOF
  else
    # Simple popup (dirbrowser, etc.)
    cat >"$script" <<NUNCHUX_EOF
#!/usr/bin/env bash
source "$NUNCHUX_BIN_DIR/nunchux-run"
cd "$dir"
$cmd
rm -f "$script"
NUNCHUX_EOF
  fi

  chmod +x "$script"
  local title=" $NUNCHUX_LABEL: $name "
  tmux run-shell -b "sleep 0.05; tmux display-popup -E -b rounded -T '$title' -w '$width' -h '$height' '$script'"
}

# Detect if we're being sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Executed directly: apply env and run command
  set -euo pipefail
  _nunchux_apply_env
  exec "$@"
else
  # Sourced: just apply env
  _nunchux_apply_env
fi

# vim: ft=bash ts=2 sw=2 et
