#!/usr/bin/env bash
#
# nunchux - Smart tmux app launcher
#
# Features:
#   - fzf-powered app selection with fuzzy search
#   - Shows running indicator for active apps
#   - Switches to existing window or opens new one
#   - Ctrl-X to kill a running app
#   - Opens apps in current working directory
#

set -euo pipefail

# Determine script directory and add to PATH
NUNCHUX_BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export PATH="$NUNCHUX_BIN_DIR:$PATH"
tmux set-environment -g NUNCHUX_BIN "$NUNCHUX_BIN_DIR"
tmux set-environment -g PATH "$NUNCHUX_BIN_DIR:$PATH"

NUNCHUX_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/nunchux"
NUNCHUX_RC_FILE="$NUNCHUX_CONFIG_DIR/config"
NUNCHUX_RC_FALLBACK="$HOME/.nunchuxrc"

# Defaults (can be overridden in config)
ICON_RUNNING="●"
ICON_STOPPED="○"

# Default menu popup dimensions (the fzf selector)
MENU_WIDTH="60%"
MENU_HEIGHT="50%"

# Default app popup dimensions
APP_POPUP_WIDTH="90%"
APP_POPUP_HEIGHT="90%"

# Justfile integration (set to false to disable)
JUST_ENABLED=true

# package.json scripts integration (set to false to disable)
NPM_ENABLED=true

# FZF styling
FZF_PROMPT=" "
FZF_POINTER="▶"
FZF_BORDER="rounded"
FZF_BORDER_LABEL=" nunchux "
FZF_COLORS="fg+:white:bold,bg+:-1,hl:cyan,hl+:cyan:bold,pointer:cyan,marker:green,header:gray,border:gray"

# App storage
declare -a CHUCKS=()
declare -A CHUCK_STATUS=()
declare -A SUBMENUS=()

# Current submenu filter (empty = main menu)
CURRENT_SUBMENU=""

# Parse INI config file
parse_config() {
    local config_file="$1"
    local current_section=""
    local line key value
    local continued_value="" continued_key=""
    local app_cmd="" app_desc="" app_width="" app_height="" app_status="" app_status_script="" app_on_exit=""

    save_app() {
        if [[ -n "$current_section" && "$current_section" != "settings" && -n "$app_cmd" ]]; then
            CHUCKS+=("$current_section:$app_cmd:$app_desc:$app_width:$app_height:$app_on_exit")
            # Track submenu if section contains /
            if [[ "$current_section" == */* ]]; then
                local submenu_name="${current_section%%/*}"
                SUBMENUS["$submenu_name"]=1
            fi
            if [[ -n "$app_status_script" ]]; then
                CHUCK_STATUS["$current_section"]="source ${app_status_script/#\~/$HOME}"
            elif [[ -n "$app_status" ]]; then
                CHUCK_STATUS["$current_section"]="$app_status"
            fi
        fi
    }

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Handle line continuation
        if [[ -n "$continued_key" ]]; then
            line="${line#"${line%%[![:space:]]*}"}"
            if [[ "$line" == *\\ ]]; then
                continued_value+="${line%\\}"
                continue
            else
                continued_value+="$line"
                line="$continued_key = $continued_value"
                continued_key=""
                continued_value=""
            fi
        fi

        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ "$line" =~ ^[[:space:]]*$ ]] && continue

        # Section header
        if [[ "$line" =~ ^\[([^\]]+)\] ]]; then
            save_app
            current_section="${BASH_REMATCH[1]}"
            app_cmd="" app_desc="" app_width="" app_height="" app_status="" app_status_script="" app_on_exit=""
            continue
        fi

        # Key = value (split on first =)
        if [[ "$line" =~ ^[[:space:]]*([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            key="${key%"${key##*[![:space:]]}"}"
            key="${key#"${key%%[![:space:]]*}"}"
            value="${value#"${value%%[![:space:]]*}"}"

            # Line continuation
            if [[ "$value" == *\\ ]]; then
                continued_key="$key"
                continued_value="${value%\\}"
                continue
            fi

            if [[ "$current_section" == "settings" ]]; then
                case "$key" in
                    icon_running) ICON_RUNNING="$value" ;;
                    icon_stopped) ICON_STOPPED="$value" ;;
                    menu_width) MENU_WIDTH="$value" ;;
                    menu_height) MENU_HEIGHT="$value" ;;
                    popup_width) APP_POPUP_WIDTH="$value" ;;
                    popup_height) APP_POPUP_HEIGHT="$value" ;;
                    just_enabled) JUST_ENABLED="$value" ;;
                    npm_enabled) NPM_ENABLED="$value" ;;
                    fzf_prompt) FZF_PROMPT="$value" ;;
                    fzf_pointer) FZF_POINTER="$value" ;;
                    fzf_border) FZF_BORDER="$value" ;;
                    fzf_border_label) FZF_BORDER_LABEL="$value" ;;
                    fzf_colors) FZF_COLORS="$value" ;;
                esac
            else
                case "$key" in
                    cmd) app_cmd="$value" ;;
                    desc) app_desc="$value" ;;
                    width) app_width="$value" ;;
                    height) app_height="$value" ;;
                    status) app_status="$value" ;;
                    status_script) app_status_script="${value/#\~/$HOME}" ;;
                    on_exit) app_on_exit="$value" ;;
                esac
            fi
        fi
    done < "$config_file"

    save_app
}

# Load config
if [[ -f "$NUNCHUX_RC_FILE" ]]; then
    parse_config "$NUNCHUX_RC_FILE"
elif [[ -f "$NUNCHUX_RC_FALLBACK" ]]; then
    parse_config "$NUNCHUX_RC_FALLBACK"
fi

# Default apps if none configured
if [[ ${#CHUCKS[@]} -eq 0 ]]; then
    CHUCKS+=("btop:btop:System monitor::")
    CHUCKS+=("lazygit:lazygit:Git TUI::")
    CHUCKS+=("lazydocker:lazydocker:Docker TUI::")
fi

# Get apps from CHUCKS array
load_apps() {
    printf '%s\n' "${CHUCKS[@]}"
}

# Parse app spec (name:cmd:desc:width:height)
get_app_name() { echo "${1%%:*}"; }
get_app_command() {
    local rest="${1#*:}"
    echo "${rest%%:*}"
}
get_app_description() {
    local spec="$1"
    echo "$spec" | cut -d: -f3
}
get_app_width() {
    local spec="$1"
    echo "$spec" | cut -d: -f4
}
get_app_height() {
    local spec="$1"
    echo "$spec" | cut -d: -f5
}
get_app_on_exit() {
    local spec="$1"
    echo "$spec" | cut -d: -f6
}

# Check if app is running (has a tmux window with that name)
is_app_running() {
    local name="$1"
    tmux list-windows -F '#{window_name}' 2>/dev/null | grep -qx "$name"
}

# Get list of running app windows
get_running_apps() {
    tmux list-windows -F '#{window_name}' 2>/dev/null || true
}

# Find justfile by searching upward from given directory
find_justfile() {
    local dir="$1"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/justfile" || -f "$dir/Justfile" || -f "$dir/.justfile" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Get just recipes from a directory
get_just_recipes() {
    local dir="$1"
    just --justfile "$dir/justfile" --summary 2>/dev/null || \
    just --justfile "$dir/Justfile" --summary 2>/dev/null || \
    just --justfile "$dir/.justfile" --summary 2>/dev/null || true
}

# Find package.json by searching upward from given directory
find_package_json() {
    local dir="$1"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/package.json" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Get npm scripts from a directory
get_npm_scripts() {
    local dir="$1"
    if command -v jq &>/dev/null; then
        jq -r '.scripts // {} | keys[]' "$dir/package.json" 2>/dev/null || true
    else
        # Fallback without jq - basic grep approach
        grep -oP '(?<="scripts"\s*:\s*\{)[^}]*' "$dir/package.json" 2>/dev/null | \
            grep -oP '"[^"]+"\s*:' | tr -d '":' | tr -s ' ' '\n' || true
    fi
}

# Build the fzf menu entries
build_menu() {
    local running_apps
    running_apps=$(get_running_apps)

    # If in main menu, show submenu entries first
    if [[ -z "$CURRENT_SUBMENU" ]]; then
        for submenu in "${!SUBMENUS[@]}"; do
            # Format: visible_part \t name \t command \t width \t height \t on_exit
            # Use special submenu: prefix for name to identify it
            printf "▸  %-12s  %s\t%s\t%s\t%s\t%s\t%s\n" "$submenu" "" "submenu:$submenu" "" "" ""
        done
    fi

    while IFS= read -r app; do
        local full_name name display_name cmd desc width height on_exit icon status_output
        full_name=$(get_app_name "$app")
        cmd=$(get_app_command "$app")
        desc=$(get_app_description "$app")
        width=$(get_app_width "$app")
        height=$(get_app_height "$app")
        on_exit=$(get_app_on_exit "$app")

        # Handle submenu filtering
        if [[ -z "$CURRENT_SUBMENU" ]]; then
            # Main menu: skip items that belong to a submenu
            [[ "$full_name" == */* ]] && continue
            display_name="$full_name"
            name="$full_name"
        else
            # Submenu mode: only show items in this submenu
            [[ "$full_name" != "$CURRENT_SUBMENU/"* ]] && continue
            # Display name is the part after the /
            display_name="${full_name#*/}"
            name="$full_name"
        fi

        if echo "$running_apps" | grep -qx "$name"; then
            icon="$ICON_RUNNING"
        else
            icon="$ICON_STOPPED"
        fi

        # Run status command if defined
        if [[ -n "${CHUCK_STATUS[$name]:-}" ]]; then
            status_output=$(eval "${CHUCK_STATUS[$name]}" 2>/dev/null || true)
            if [[ -n "$status_output" ]]; then
                if [[ -n "$desc" ]]; then
                    desc="$desc $status_output"
                else
                    desc="$status_output"
                fi
            fi
        fi

        # Format: visible_part \t name \t command \t width \t height \t on_exit
        printf "%s  %-12s  %s\t%s\t%s\t%s\t%s\t%s\n" "$icon" "$display_name" "$desc" "$name" "$cmd" "$width" "$height" "$on_exit"
    done < <(load_apps)

    # Add just recipes if justfile exists and enabled
    if [[ "$JUST_ENABLED" == "true" ]]; then
        local current_dir justfile_dir recipes
        current_dir=$(get_current_dir)
        if justfile_dir=$(find_justfile "$current_dir"); then
            recipes=$(get_just_recipes "$justfile_dir")
            if [[ -n "$recipes" ]]; then
                # Divider
                printf "   ─── just ───────────────────\t\t\t\t\t\n"
                for recipe in $recipes; do
                    # Format: visible_part \t name \t command \t width \t height
                    printf "»  %-12s  %s\t%s\t%s\t%s\t%s\n" "$recipe" "" "just:$recipe" "cd $justfile_dir && just $recipe" "" ""
                done
            fi
        fi
    fi

    # Add npm scripts if package.json exists and enabled
    if [[ "$NPM_ENABLED" == "true" ]]; then
        local current_dir pkg_dir scripts
        current_dir=$(get_current_dir)
        if pkg_dir=$(find_package_json "$current_dir"); then
            scripts=$(get_npm_scripts "$pkg_dir")
            if [[ -n "$scripts" ]]; then
                # Divider
                printf "   ─── npm ────────────────────\t\t\t\t\t\n"
                while IFS= read -r script; do
                    [[ -z "$script" ]] && continue
                    # Format: visible_part \t name \t command \t width \t height
                    printf "»  %-12s  %s\t%s\t%s\t%s\t%s\n" "$script" "" "npm:$script" "cd $pkg_dir && npm run $script" "" ""
                done <<< "$scripts"
            fi
        fi
    fi
}

# Get current pane's working directory
get_current_dir() {
    tmux display-message -p '#{pane_current_path}' 2>/dev/null || pwd
}

# Switch to an existing app window
switch_to_app() {
    local name="$1"
    tmux select-window -t "$name" 2>/dev/null
}

# Open a new app in a new tmux window
open_app() {
    local name="$1"
    local cmd="$2"
    local dir
    dir=$(get_current_dir)

    # Create new window with the app
    tmux new-window -n "$name" -c "$dir" "$cmd"
}

# Open app in a new popup with app-specific dimensions
open_popup() {
    local name="$1"
    local cmd="$2"
    local app_width="$3"
    local app_height="$4"
    local on_exit="$5"
    local dir
    dir=$(get_current_dir)

    # Use app-specific dimensions, fall back to defaults
    local width height
    width="${app_width:-$APP_POPUP_WIDTH}"
    height="${app_height:-$APP_POPUP_HEIGHT}"
    # Add % suffix if just a number
    [[ "$width" =~ ^[0-9]+$ ]] && width="${width}%"
    [[ "$height" =~ ^[0-9]+$ ]] && height="${height}%"

    if [[ -n "$on_exit" ]]; then
        # Set up variables for substitution
        local pane_id tmp script_file
        pane_id=$(tmux display-message -p '#{pane_id}')
        tmp="/tmp/nunchux-tmp-$$"
        script_file="/tmp/nunchux-script-$$"

        # Substitute variables in cmd and on_exit
        local expanded_cmd="$cmd"
        local expanded_on_exit="$on_exit"
        expanded_cmd="${expanded_cmd//\{pane_id\}/$pane_id}"
        expanded_cmd="${expanded_cmd//\{tmp\}/$tmp}"
        expanded_cmd="${expanded_cmd//\{dir\}/$dir}"
        expanded_on_exit="${expanded_on_exit//\{pane_id\}/$pane_id}"
        expanded_on_exit="${expanded_on_exit//\{tmp\}/$tmp}"
        expanded_on_exit="${expanded_on_exit//\{dir\}/$dir}"

        # Write command to temp script to avoid quoting issues
        cat > "$script_file" << NUNCHUX_EOF
#!/usr/bin/env bash
cd "$dir"
$expanded_cmd
$expanded_on_exit
rm -f "$script_file"
NUNCHUX_EOF
        chmod +x "$script_file"

        tmux run-shell -b "tmux display-popup -E -b rounded -T ' nunchux: $name ' -w $width -h $height '$script_file'"
    else
        # Schedule new popup and exit current one
        tmux run-shell -b "tmux display-popup -E -b rounded -T ' nunchux: $name ' -w $width -h $height -d \"$dir\" $cmd"
    fi
    exit 0
}

# Kill a running app window
kill_app() {
    local name="$1"
    if is_app_running "$name"; then
        tmux kill-window -t "$name" 2>/dev/null
        echo "Killed: $name"
    fi
}

# Main launcher using fzf
launch() {
    # Check dependencies
    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf is required. Install it first." >&2
        exit 1
    fi

    if ! command -v tmux &>/dev/null; then
        echo "Error: tmux is required." >&2
        exit 1
    fi

    if [[ -z "${TMUX:-}" ]]; then
        echo "Error: Must be run inside tmux." >&2
        exit 1
    fi

    local selection
    local script_path
    script_path=$(realpath "$0")

    # Build reload command with submenu context
    local reload_cmd="$script_path --menu"
    local header="Enter: popup | Ctrl-O: window | Ctrl-X: kill"
    if [[ -n "$CURRENT_SUBMENU" ]]; then
        reload_cmd="$script_path --menu --submenu $CURRENT_SUBMENU"
        header="Enter: popup | Ctrl-O: window | Ctrl-X: kill | Esc: back"
    fi

    # Run fzf with our menu
    selection=$(build_menu | fzf \
        --delimiter='\t' \
        --with-nth=1 \
        --header="$header" \
        --header-first \
        --prompt="$FZF_PROMPT" \
        --pointer="$FZF_POINTER" \
        --layout=reverse \
        --height=100% \
        --border="$FZF_BORDER" \
        --border-label="$FZF_BORDER_LABEL" \
        --border-label-pos=3 \
        --no-preview \
        --expect=ctrl-o \
        --bind="ctrl-x:reload($script_path --kill {2} >/dev/null 2>&1; $reload_cmd)" \
        --color="$FZF_COLORS" \
    ) || true

    if [[ -z "$selection" ]]; then
        return 0
    fi

    # Parse: first line is key pressed (if --expect matched), rest is selection
    local key selected_line
    key=$(echo "$selection" | head -1)
    selected_line=$(echo "$selection" | tail -1)

    if [[ -z "$selected_line" ]]; then
        return 0
    fi

    # Extract fields (tab-separated: visible \t name \t cmd \t width \t height \t on_exit)
    local name cmd width height on_exit
    name=$(echo "$selected_line" | cut -f2)
    cmd=$(echo "$selected_line" | cut -f3)
    width=$(echo "$selected_line" | cut -f4)
    height=$(echo "$selected_line" | cut -f5)
    on_exit=$(echo "$selected_line" | cut -f6)

    if [[ -z "$name" ]]; then
        return 0
    fi

    # Handle based on key pressed
    if [[ "$key" == "ctrl-o" ]]; then
        if is_app_running "$name"; then
            switch_to_app "$name"
        else
            open_app "$name" "$cmd"
        fi
    elif [[ "$name" == submenu:* ]]; then
        # Open submenu - exec ourselves with --submenu flag
        local submenu_name="${name#submenu:}"
        exec "$script_path" --submenu "$submenu_name"
    elif [[ "$name" == just:* || "$name" == npm:* ]]; then
        # Just recipes and npm scripts run in current pane
        tmux send-keys "$cmd" Enter
    elif is_app_running "$name"; then
        # App is running, switch to it
        switch_to_app "$name"
    else
        open_popup "$name" "$cmd" "$width" "$height" "$on_exit"
    fi
}

# Show help
usage() {
    cat <<EOF
nunchux - Smart tmux app launcher

Usage: nunchux [options]

Options:
    (none)          Launch the app selector
    --list          List configured apps
    --help          Show this help

Configuration:
    Config file: $NUNCHUX_RC_FILE
    Fallback:    $NUNCHUX_RC_FALLBACK

    Example config:
        # Icons
        ICON_RUNNING="●"
        ICON_STOPPED="○"

        # Default popup dimensions
        APP_POPUP_WIDTH="90%"
        APP_POPUP_HEIGHT="90%"

        # Apps: chuck name command description [width] [height]
        chuck btop       "btop"         "System monitor"
        chuck lazygit    "lazygit"      "Git TUI"         95 95
        chuck notes      "nvim ~/notes" "Quick notes"     80 60

Controls:
    Enter           Open in popup
    Ctrl-O          Open in window (or switch if running)
    Ctrl-X          Kill running app
    Escape          Cancel
EOF
}

# List apps
list_apps() {
    echo "Configured apps:"
    echo ""
    while IFS= read -r app; do
        local name cmd desc
        name=$(get_app_name "$app")
        cmd=$(get_app_command "$app")
        desc=$(get_app_description "$app")

        if is_app_running "$name"; then
            printf "  %s %-12s %s\n" "$ICON_RUNNING" "$name" "$desc"
        else
            printf "  %s %-12s %s\n" "$ICON_STOPPED" "$name" "$desc"
        fi
    done < <(load_apps)
}

# Main
main() {
    case "${1:-}" in
        --kill)
            shift
            kill_app "$1"
            ;;
        --menu)
            # Support --menu with optional submenu filter
            if [[ "${2:-}" == "--submenu" ]]; then
                CURRENT_SUBMENU="$3"
            fi
            build_menu
            ;;
        --list)
            list_apps
            ;;
        --config)
            shift
            case "${1:-}" in
                menu_width) echo "$MENU_WIDTH" ;;
                menu_height) echo "$MENU_HEIGHT" ;;
                popup_width) echo "$APP_POPUP_WIDTH" ;;
                popup_height) echo "$APP_POPUP_HEIGHT" ;;
                *) echo "Unknown config: $1" >&2; exit 1 ;;
            esac
            ;;
        --submenu)
            shift
            CURRENT_SUBMENU="$1"
            FZF_BORDER_LABEL=" $CURRENT_SUBMENU "
            launch
            ;;
        --help|-h|help)
            usage
            ;;
        "")
            launch
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
    esac
}

main "$@"
