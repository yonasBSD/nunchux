#!/usr/bin/env bash
#
# nunchux - Smart tmux app launcher
#
# A modular command palette for tmux with support for:
#   - Apps (TUI applications in popups/windows)
#   - Submenus (organized collections)
#   - Directory browsers (file navigation)
#   - Task runners (just, npm, task integration)
#

set -euo pipefail

# Error handler - show Chuck Norris error screen and wait
show_error_screen() {
  local line="$1"
  local cmd="$2"

  clear

  # Center text helper
  center() {
    local text="$1"
    local width=$(tput cols)
    local plain=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_len=${#plain}
    local padding=$(((width - text_len) / 2))
    [[ $padding -gt 0 ]] && printf "%*s" $padding ""
    echo -e "$text"
  }

  local height=$(tput lines)
  local top_padding=$(((height - 20) / 2))
  for ((i = 0; i < top_padding; i++)); do echo; done

  center "\033[1;33mChuck Norris can divide by zero\033[0m"
  echo ""
  center "\033[90mbut...\033[0m"
  echo ""

  # Nunchucks ASCII art
  local art='   ____
  |    |
  |    |===={####}
  |    |
  |____|'
  while IFS= read -r artline; do
    center "$artline"
  done <<<"$art"

  echo ""
  echo ""
  center "\033[1;31mError on line $line\033[0m"
  echo ""
  center "\033[90m$cmd\033[0m"
  echo ""
  echo ""
  center "\033[90mpress any key\033[0m"
  read -n 1 -s
}

trap 'show_error_screen "$LINENO" "$BASH_COMMAND"' ERR

# Determine script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Clear shortcut display state (set via --show-shortcuts flag only)
unset SHOW_SHORTCUTS

# Load core library (which loads all other libs)
source "$SCRIPT_DIR/../lib/core.sh"

# Set tmux environment
tmux set-environment -g NUNCHUX_BIN "$NUNCHUX_BIN_DIR"

# Load all modules
load_modules

# Check for old config format and offer migration
check_and_migrate_config || exit 0

# Check for old order format and offer migration
check_and_migrate_order_config || exit 0

# Load and parse config
config_file=$(get_config_file)
if [[ -n "$config_file" ]]; then
  parse_config "$config_file"
fi

# Initialize help display state from config (can be toggled with ctrl-/)
if [[ "${SHOW_HELP:-true}" == "true" ]]; then
  SHOW_SHORTCUTS=1
fi

# Show invalid keybinding error
show_invalid_key_error() {
  local invalid_key="$1"
  clear

  center() {
    local text="$1"
    local width=$(tput cols)
    local plain=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_len=${#plain}
    local padding=$(((width - text_len) / 2))
    [[ $padding -gt 0 ]] && printf "%*s" $padding ""
    echo -e "$text"
  }

  local height=$(tput lines)
  local top_padding=$(((height - 24) / 2))
  for ((i = 0; i < top_padding; i++)); do echo; done

  center "\033[1;33mChuck Norris doesn't need keybindings\033[0m"
  echo ""
  center "\033[90mbut you do...\033[0m"
  echo ""
  while IFS= read -r line; do
    center "$line"
  done <<<"$NUNCHUCKS_ART"
  echo ""
  echo ""
  center "\033[1;31mUnsupported key: $invalid_key\033[0m"
  echo ""
  center "\033[90mKeys like shift-enter and ctrl-enter are not supported by terminals.\033[0m"
  echo ""
  center "\033[1;37mGood alternatives:\033[0m"
  center "alt-enter  ctrl-s  tab  ctrl-o"
  echo ""
  center "\033[90mSee: https://man.archlinux.org/man/fzf.1.en\033[0m"
  echo ""
  center "\033[90mpress any key\033[0m"
  read -n 1 -s
  exit 0 # Exit cleanly - user already saw the error
}

# Validate keybindings before proceeding
invalid_keys=$(validate_keybindings) || show_invalid_key_error "$invalid_keys"

# Load enabled taskrunners
load_taskrunners

# Show invalid shortcut error
show_invalid_shortcut_error() {
  local errors="$1"
  clear

  center() {
    local text="$1"
    local width=$(tput cols)
    local plain=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_len=${#plain}
    local padding=$(((width - text_len) / 2))
    [[ $padding -gt 0 ]] && printf "%*s" $padding ""
    echo -e "$text"
  }

  local height=$(tput lines)
  local top_padding=$(((height - 24) / 2))
  for ((i = 0; i < top_padding; i++)); do echo; done

  center "\033[1;33mChuck Norris doesn't need shortcuts\033[0m"
  echo ""
  center "\033[90mbut you might want to fix yours...\033[0m"
  echo ""
  while IFS= read -r line; do
    center "$line"
  done <<<"$NUNCHUCKS_ART"
  echo ""
  echo ""
  center "\033[1;31mInvalid shortcuts:\033[0m"
  echo ""
  while IFS= read -r err; do
    [[ -n "$err" ]] && center "\033[90m$err\033[0m"
  done <<<"$errors"
  echo ""
  center "\033[90mReserved keys: enter, esc, ctrl-x, /, $PRIMARY_KEY, $SECONDARY_KEY\033[0m"
  echo ""
  center "\033[90mpress any key\033[0m"
  read -n 1 -s
  exit 0
}

# Register all shortcuts after config is fully parsed
register_all_shortcuts() {
  local errors=""

  # Helper to register a single shortcut and collect errors
  _try_register() {
    local key="$1" item="$2" registry_key="$3"

    [[ -z "$key" ]] && return 0

    if ! validate_shortcut "$key" "$item" 2>/dev/null; then
      errors+="$key ($item) - "
      if ! is_valid_fzf_key "$key"; then
        errors+="invalid fzf key"
      else
        errors+="reserved key"
      fi
      errors+=$'\n'
    elif ! register_shortcut "$key" "$registry_key" 2>/dev/null; then
      errors+="$key ($item) - duplicate of ${SHORTCUT_REGISTRY[$key]}"$'\n'
    fi
  }

  local name
  for name in "${APP_ORDER[@]}"; do
    _try_register "${APP_SHORTCUT[$name]:-}" "app:$name" "$name"
  done

  for name in "${MENU_ORDER[@]}"; do
    _try_register "${MENU_SHORTCUT[$name]:-}" "menu:$name" "menu:$name"
  done

  for name in "${DIRBROWSE_ORDER[@]}"; do
    _try_register "${DIRBROWSE_SHORTCUT[$name]:-}" "dirbrowser:$name" "dirbrowser:$name"
  done

  unset -f _try_register

  if [[ -n "$errors" ]]; then
    show_invalid_shortcut_error "$errors"
  fi
}

register_all_shortcuts

# Launch an item by shortcut
launch_by_shortcut() {
  local item="$1"

  if [[ "$item" == menu:* ]]; then
    # Enter submenu
    CURRENT_MENU="${item#menu:}"
    launch
  elif [[ "$item" == dirbrowser:* ]]; then
    # Enter dirbrowser
    launch_dirbrowse "${item#dirbrowser:}"
  else
    # Launch app with primary action
    local cmd="${APP_CMD[$item]:-}"
    [[ -z "$cmd" ]] && {
      echo "Unknown item: $item" >&2
      exit 1
    }
    app_launch "$item" "" "$cmd" "${APP_WIDTH[$item]:-}" "${APP_HEIGHT[$item]:-}" "${APP_ON_EXIT[$item]:-}"
  fi
}

# Check if any items are configured
has_config() {
  app_has_items || menu_has_items || dirbrowser_has_items || taskrunner_has_items
}

# No config popup - offers to create initial config
show_no_config_popup() {
  local script_file="/tmp/nunchux-noconfig-$$"
  local config_dir="$NUNCHUX_CONFIG_DIR"
  local config_file="$NUNCHUX_RC_FILE"

  cat >"$script_file" <<'NOCONFIG_EOF'
#!/usr/bin/env bash
CONFIG_DIR="$1"
CONFIG_FILE="$2"

center() {
    local text="$1"
    local width=$(tput cols)
    local plain=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_len=${#plain}
    local padding=$(( (width - text_len) / 2 ))
    [[ $padding -gt 0 ]] && printf "%*s" $padding ""
    echo -e "$text"
}

show_menu() {
    clear
    height=$(tput lines)
    top_padding=$(( (height - 16) / 2 ))
    for ((i=0; i<top_padding; i++)); do echo; done

    center "\033[1;36mNo config file found\033[0m"
    echo ""
    center "\033[90mCreate one to get started?\033[0m"
    echo ""
NOCONFIG_EOF

  # Append the nunchucks art
  while IFS= read -r line; do
    printf '    center "%s"\n' "$line" >>"$script_file"
  done <<<"$NUNCHUCKS_ART"

  cat >>"$script_file" <<'NOCONFIG_EOF2'
    echo ""
    echo ""
    center "\033[1;32m[Enter]\033[0m \033[90mCreate config at $CONFIG_FILE\033[0m"
    center "\033[1;31m[Esc]\033[0m   \033[90mExit\033[0m"
}

create_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << 'CONFIG'
# Nunchux Configuration
# Edit this file to customize your apps.
# See docs/configuration.md for all options.

[settings]
popup_width = 90%
popup_height = 90%

# Apps use [app:name] format
[app:lazygit]
cmd = lazygit
status = n=$(git status -s 2>/dev/null | wc -l | tr -d ' '); [[ $n -gt 0 ]] && echo "($n changed)"

[app:notes]
cmd = f=$(nearest notes.md) && nvim "$f" || echo "No notes.md found"
width = 80
height = 60
status = f=$(nearest notes.md) && echo "($(wc -l < "$f") lines)"

# Submenus use [menu:name] format
[menu:system]
status = echo "load: $(cut -d' ' -f1 /proc/loadavg)"

# Apps in submenus use [app:parent/name] format
[app:system/htop]
cmd = htop
desc = Process viewer

[app:system/disk]
cmd = ncdu ~
desc = Disk usage analyzer

# Directory browsers use [dirbrowser:name] format
[dirbrowser:configs]
directory = ~/.config
depth = 2
sort = modified-folder

# Task runners (disabled by default)
# [taskrunner:just]
# enabled = true
# icon = ðŸ¤–
CONFIG
}

show_menu

while true; do
    read -rsn1 key
    case "$key" in
        $'\x1b')
            rm -f "$0"
            exit 0
            ;;
        "")
            create_config
            clear
            height=$(tput lines)
            top_padding=$(( (height - 8) / 2 ))
            for ((i=0; i<top_padding; i++)); do echo; done
            center "\033[1;32mConfig created!\033[0m"
            echo ""
            center "\033[90m$CONFIG_FILE\033[0m"
            echo ""
            center "\033[90mEdit it to add your apps, then run nunchux again.\033[0m"
            echo ""
            center "\033[90mpress any key\033[0m"
            read -n 1 -s
            rm -f "$0"
            exit 0
            ;;
    esac
done
NOCONFIG_EOF2

  chmod +x "$script_file"
  tmux display-popup -E -b rounded -w "$MENU_WIDTH" -h "$MENU_HEIGHT" "$script_file" "$config_dir" "$config_file"
  exit 0
}

# Build combined menu
build_menu() {
  build_combined_menu "$CURRENT_MENU"
}

# Main launcher using fzf
launch() {
  # Build border label (includes cwd if configured)
  build_border_label "$CURRENT_MENU"

  # Check dependencies
  if ! check_fzf_version; then
    echo "Install fzf $FZF_MIN_VERSION+ from https://github.com/junegunn/fzf" >&2
    exit 1
  fi

  if ! command -v tmux &>/dev/null; then
    echo "Error: tmux is required." >&2
    exit 1
  fi

  if ! command -v curl &>/dev/null; then
    echo "Error: curl is required for menu hot-swap." >&2
    exit 1
  fi

  if [[ -z "${TMUX:-}" ]]; then
    echo "Error: Must be run inside tmux." >&2
    exit 1
  fi

  # No config? Offer to create one
  if ! has_config; then
    if has_config_file; then
      echo "Config file exists but has no items configured."
      echo "Edit $NUNCHUX_RC_FILE to add your apps."
      exit 0
    else
      show_no_config_popup
    fi
  fi

  local selection
  local script_path
  script_path=$(realpath "$0")

  # Build reload command with submenu context
  local reload_cmd="$script_path --menu"
  local primary_display="${PRIMARY_KEY^}"
  local secondary_display="${SECONDARY_KEY^}"

  # Build header (only shown when SHOW_SHORTCUTS is set)
  local header=""
  if [[ -n "$SHOW_SHORTCUTS" ]]; then
    header="$primary_display: $PRIMARY_ACTION | $secondary_display: $SECONDARY_ACTION | Ctrl-X: kill"
    [[ -n "$CURRENT_MENU" ]] && header="$header | Esc: back"
    # Add action shortcuts (same line)
    [[ -n "$POPUP_KEY" ]] && header="$header | ${POPUP_KEY^}: popup"
    [[ -n "$WINDOW_KEY" ]] && header="$header | ${WINDOW_KEY^}: window"
    [[ -n "$BACKGROUND_WINDOW_KEY" ]] && header="$header | ${BACKGROUND_WINDOW_KEY^}: bg"
    [[ -n "$PANE_HORIZONTAL_KEY" ]] && header="$header | ${PANE_HORIZONTAL_KEY^}: hsplit"
    [[ -n "$PANE_VERTICAL_KEY" ]] && header="$header | ${PANE_VERTICAL_KEY^}: vsplit"
    [[ -n "$ACTION_MENU_KEY" ]] && header="$header | ${ACTION_MENU_KEY^}: actions"
  fi

  if [[ -n "$CURRENT_MENU" ]]; then
    reload_cmd="$script_path --menu --submenu $CURRENT_MENU"
  fi

  # Cache settings
  local cache_file socket cache_ttl
  cache_ttl="$MENU_CACHE_TTL"

  if [[ -z "$CURRENT_MENU" ]]; then
    # Include cwd hash in cache key (items are directory-dependent)
    local cwd_hash
    cwd_hash=$(printf '%s' "$PWD" | md5sum | cut -c1-8)
    cache_file=$(cache_file "main-menu-$cwd_hash")
    socket=$(cache_socket "main-menu-$cwd_hash")
  else
    cache_file=$(cache_file "submenu" "$CURRENT_MENU")
    socket=$(cache_socket "submenu" "$CURRENT_MENU")
    cache_ttl="${SUBMENU_CACHE_TTL[$CURRENT_MENU]:-$MENU_CACHE_TTL}"
  fi

  # Build fzf options
  local fzf_opts
  build_fzf_opts fzf_opts "$header"
  fzf_opts+=(--bind="ctrl-x:reload($script_path --kill {3} >/dev/null 2>&1; $reload_cmd)")

  # Add shortcut bindings
  local shortcut_binds=()
  build_shortcut_binds shortcut_binds "$script_path"
  fzf_opts+=("${shortcut_binds[@]}")

  # Add ctrl-/ toggle for shortcuts display
  local toggle_cmd="$script_path"
  [[ -n "$CURRENT_MENU" ]] && toggle_cmd="$toggle_cmd --submenu $CURRENT_MENU"

  if [[ -n "$SHOW_SHORTCUTS" ]]; then
    fzf_opts+=(--bind="ctrl-/:become($toggle_cmd --hide-shortcuts)")
  else
    fzf_opts+=(--bind="ctrl-/:become($toggle_cmd --show-shortcuts)")
  fi

  # Run with cache if valid (but skip cache when showing shortcuts to avoid hot-swap issues)
  local fzf_exit=0
  local fzf_stderr="/tmp/nunchux-fzf-stderr-$$"
  if [[ -n "$SHOW_SHORTCUTS" ]]; then
    # When showing shortcuts, build fresh each time (no caching)
    selection=$(build_menu | add_shortcut_prefixes | fzf "${fzf_opts[@]}" 2>"$fzf_stderr") || fzf_exit=$?
  elif is_cache_valid "$cache_file" "$cache_ttl"; then
    # Clean up any leftover socket from previous invocation (e.g., if fzf was replaced via become())
    rm -f "$socket" 2>/dev/null || true
    refresh_cache "$cache_file" "$socket" build_menu &
    local refresh_pid=$!
    selection=$(cat "$cache_file" | fzf "${fzf_opts[@]}" --listen "$socket" 2>"$fzf_stderr") || fzf_exit=$?
    kill $refresh_pid 2>/dev/null || true
    rm -f "$socket" 2>/dev/null || true
  else
    selection=$(build_menu | tee "$cache_file" | fzf "${fzf_opts[@]}" 2>"$fzf_stderr") || fzf_exit=$?
  fi

  # If fzf failed (not just cancelled), show error
  if [[ $fzf_exit -ne 0 && $fzf_exit -ne 130 ]]; then
    echo ""
    echo "fzf exited with code $fzf_exit"
    if [[ -s "$fzf_stderr" ]]; then
      echo ""
      echo "Error output:"
      cat "$fzf_stderr"
    fi
    echo ""
    echo "fzf options: ${fzf_opts[*]}"
    echo ""
    echo "Press any key..."
    read -n 1 -s
    rm -f "$fzf_stderr"
    return 1
  fi
  rm -f "$fzf_stderr"

  if [[ -z "$selection" ]]; then
    return 0
  fi

  # Debug: log selection to temp file if NUNCHUX_DEBUG is set
  if [[ -n "${NUNCHUX_DEBUG:-}" ]]; then
    echo "=== $(date) ===" >>/tmp/nunchux-debug.log
    echo "Raw selection:" >>/tmp/nunchux-debug.log
    echo "$selection" | cat -A >>/tmp/nunchux-debug.log
    echo "PRIMARY_KEY=$PRIMARY_KEY" >>/tmp/nunchux-debug.log
    echo "SECONDARY_KEY=$SECONDARY_KEY" >>/tmp/nunchux-debug.log
  fi

  # Parse: first line is key pressed, rest is selection
  local key selected_line
  key=$(echo "$selection" | head -1)
  selected_line=$(echo "$selection" | tail -1)

  if [[ -n "${NUNCHUX_DEBUG:-}" ]]; then
    echo "Parsed key: '$key'" >>/tmp/nunchux-debug.log
    echo "Selected line: '$selected_line'" >>/tmp/nunchux-debug.log
  fi

  if [[ -z "$selected_line" ]]; then
    return 0
  fi

  # Extract fields (tab-separated)
  # Format: display \t shortcut \t name \t cmd \t width \t height \t on_exit
  local name cmd width height on_exit
  name=$(echo "$selected_line" | cut -f3)
  cmd=$(echo "$selected_line" | cut -f4)
  width=$(echo "$selected_line" | cut -f5)
  height=$(echo "$selected_line" | cut -f6)
  on_exit=$(echo "$selected_line" | cut -f7)

  if [[ -z "$name" ]]; then
    return 0
  fi

  # Try each module until one handles it
  local handled=false
  for mod in "${LOADED_MODULES[@]}"; do
    local launcher="${mod}_launch"
    if [[ $(type -t "$launcher") == "function" ]]; then
      local result=0
      "$launcher" "$name" "$key" "$cmd" "$width" "$height" "$on_exit" || result=$?

      if [[ $result -eq 0 ]]; then
        handled=true
        # If menu module handled it, relaunch with new context
        if [[ "$mod" == "menu" && -n "$CURRENT_MENU" ]]; then
          launch
        fi
        return 0
      elif [[ $result -eq 2 ]]; then
        handled=true
        # Special return: go back to main menu
        launch
        return 0
      fi
    fi
  done

  # If nothing handled the selection, show debug info
  if [[ "$handled" == "false" ]]; then
    echo ""
    echo "No module handled this selection:"
    echo "  name: $name"
    echo "  key: '$key' (expected: '$PRIMARY_KEY' or '$SECONDARY_KEY')"
    echo "  cmd: $cmd"
    echo ""
    echo "Press any key..."
    read -n 1 -s
  fi
}

# Show help
usage() {
  cat <<EOF
nunchux - Smart tmux app launcher

Usage: nunchux [options]

Options:
    (none)              Launch the app selector
    --list              List configured apps
    --shell-init [sh]   Output shell init code (bash/zsh/fish)
    --help              Show this help

Environment Inheritance:
    To inherit your shell environment (nvm, pyenv, etc.) in apps:

    Bash: Add to ~/.bashrc:
        eval "\$(nunchux --shell-init bash)"

    Zsh: Add to ~/.zshrc:
        eval "\$(nunchux --shell-init zsh)"

Configuration:
    Searches upward from current directory for .nunchuxrc
    Falls back to: $NUNCHUX_RC_FILE

    Run nunchux without a config to create one interactively.

Controls:
    Enter           Open in popup
    Ctrl-O          Open in window (or switch if running)
    Ctrl-X          Kill running app
    Escape          Cancel
EOF
}

# List apps
list_apps() {
  echo "Configured items:"
  echo ""
  for name in "${APP_ORDER[@]}"; do
    local cmd="${APP_CMD[$name]:-}"
    local desc="${APP_DESC[$name]:-}"
    if is_app_running "$name"; then
      printf "  %s %-12s %s\n" "$ICON_RUNNING" "$name" "$desc"
    else
      printf "  %s %-12s %s\n" "$ICON_STOPPED" "$name" "$desc"
    fi
  done
}

# Output shell initialization code for environment capture
shell_init() {
  local shell_type="${1:-bash}"

  cat <<'EOF'
# Nunchux shell integration - saves environment for inheritance
# This runs after each command, so apps launched via nunchux
# inherit your current shell environment (PATH, nvm, pyenv, etc.)
if [[ -n "$TMUX_PANE" ]]; then
    _nunchux_save_env() {
        env > "/tmp/nunchux-env-$TMUX_PANE" 2>/dev/null
    }
EOF

  case "$shell_type" in
  zsh)
    cat <<'EOF'
    precmd_functions+=(_nunchux_save_env)
fi
EOF
    ;;
  fish)
    # Fish has completely different syntax
    cat <<'EOF'
if set -q TMUX_PANE
    function _nunchux_save_env --on-event fish_postexec
        env > "/tmp/nunchux-env-$TMUX_PANE" 2>/dev/null
    end
end
EOF
    return
    ;;
  *) # bash and others
    cat <<'EOF'
    PROMPT_COMMAND="_nunchux_save_env${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
fi
EOF
    ;;
  esac
}

# Main
main() {
  case "${1:-}" in
  --shell-init)
    shift
    shell_init "${1:-bash}"
    exit 0
    ;;
  --kill)
    shift
    # Try app first, then taskrunner
    kill_app "$1" 2>/dev/null || taskrunner_kill "$1" 2>/dev/null || true
    ;;
  --menu)
    if [[ "${2:-}" == "--submenu" ]]; then
      CURRENT_MENU="$3"
    fi
    build_menu
    ;;
  --list)
    list_apps
    ;;
  --config)
    shift
    case "${1:-}" in
    menu_width) echo "$MENU_WIDTH" ;;
    menu_height) echo "$MENU_HEIGHT" ;;
    max_menu_width) echo "$MAX_MENU_WIDTH" ;;
    max_menu_height) echo "$MAX_MENU_HEIGHT" ;;
    popup_width) echo "$APP_POPUP_WIDTH" ;;
    popup_height) echo "$APP_POPUP_HEIGHT" ;;
    *)
      echo "Unknown config: $1" >&2
      exit 1
      ;;
    esac
    ;;
  --popup)
    # Launch self in a tmux popup with clamped dimensions
    local width="$MENU_WIDTH" height="$MENU_HEIGHT"

    # Clamp to max if configured
    if [[ "$width" == *% && -n "${MAX_MENU_WIDTH:-}" ]]; then
      local term_cols pct_width
      term_cols=$(tmux display-message -p '#{window_width}')
      pct_width=$((term_cols * ${width%\%} / 100))
      ((pct_width > MAX_MENU_WIDTH)) && width="$MAX_MENU_WIDTH"
    fi
    if [[ "$height" == *% && -n "${MAX_MENU_HEIGHT:-}" ]]; then
      local term_lines pct_height
      term_lines=$(tmux display-message -p '#{window_height}')
      pct_height=$((term_lines * ${height%\%} / 100))
      ((pct_height > MAX_MENU_HEIGHT)) && height="$MAX_MENU_HEIGHT"
    fi

    local script_path
    script_path=$(realpath "${BASH_SOURCE[0]}")
    local dir
    dir=$(tmux display-message -p '#{pane_current_path}')

    exec tmux display-popup -E -B -d "$dir" -w "$width" -h "$height" "$script_path"
    ;;
  --submenu)
    shift
    CURRENT_MENU="$1"
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --show-shortcuts)
    SHOW_SHORTCUTS=1
    export SHOW_SHORTCUTS
    shift
    if [[ "${1:-}" == "--submenu" ]]; then
      CURRENT_MENU="$2"
    fi
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --hide-shortcuts)
    SHOW_SHORTCUTS=""
    shift
    if [[ "${1:-}" == "--submenu" ]]; then
      CURRENT_MENU="$2"
    fi
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --launch-shortcut)
    shift
    launch_by_shortcut "$1"
    ;;
  --help | -h | help)
    usage
    ;;
  "")
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  *)
    echo "Unknown option: $1" >&2
    usage >&2
    exit 1
    ;;
  esac
}

main "$@"

# vim: ft=bash ts=2 sw=2 et
