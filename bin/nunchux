#!/usr/bin/env bash
#
# nunchux - Smart tmux app launcher
#
# A modular command palette for tmux with support for:
#   - Apps (TUI applications in popups/windows)
#   - Submenus (organized collections)
#   - Directory browsers (file navigation)
#   - Task runners (just, npm, task integration)
#

set -euo pipefail

# Error handler - show error with Chuck Norris fact
show_error_screen() {
  local line="$1"
  local cmd="$2"

  echo ""
  # Show Chuck Norris fact if available
  if [[ ${#CHUCK_FACTS[@]} -gt 0 ]]; then
    echo -e "\033[1;33m${CHUCK_FACTS[$RANDOM % ${#CHUCK_FACTS[@]}]}\033[0m"
    echo -e "\033[90mbut...\033[0m"
    echo ""
  fi
  echo -e "\033[1;31mError on line $line\033[0m"
  echo -e "\033[90m$cmd\033[0m"
  echo ""
  echo "Press any key..."
  read -n 1 -s
}

trap 'show_error_screen "$LINENO" "$BASH_COMMAND"' ERR

# Determine script directory (avoid subprocess if possible)
if [[ "${BASH_SOURCE[0]}" == /* ]]; then
  # Absolute path - use parameter expansion (no subprocess)
  SCRIPT_DIR="${BASH_SOURCE[0]%/*}"
else
  # Relative path - need to resolve
  SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" && pwd)"
fi

# Clear shortcut display state (set via --show-shortcuts flag only)
unset SHOW_SHORTCUTS

# Load core library (which loads all other libs)
source "$SCRIPT_DIR/../lib/core.sh"

# Load all modules
load_modules

# Run pre-flight dependency checks BEFORE anything else
declare -A PREFLIGHT_FAILURES=()
if ! run_preflight_checks PREFLIGHT_FAILURES; then
  source "$NUNCHUX_LIB_DIR/error_screens.sh"
  show_setup_error "dependency" PREFLIGHT_FAILURES
fi

# Set tmux environment (after preflight confirms tmux is available)
tmux set-environment -g NUNCHUX_BIN "$NUNCHUX_BIN_DIR"

# Load and parse config (or use cache if valid)
config_file=$(get_config_file)

if [[ -n "$config_file" ]]; then
  # Check for old config format and offer migration (lazy-load migrate.sh)
  if is_old_config_format "$config_file" || needs_order_migration "$config_file"; then
    source "$NUNCHUX_LIB_DIR/migrate.sh"
    check_and_migrate_config || exit 0
    check_and_migrate_order_config || exit 0
  fi
  _config_cache="$NUNCHUX_CACHE_DIR/config-${config_file//\//_}.cache"
  if is_config_cache_valid "$config_file" "$_config_cache"; then
    source "$_config_cache"
  else
    parse_config "$config_file"
    _NUNCHUX_SAVE_CONFIG_CACHE=1
  fi
fi

# Initialize help display state from config (can be toggled with ctrl-/)
if [[ "${SHOW_HELP:-true}" == "true" ]]; then
  SHOW_SHORTCUTS=1
fi

# Validate keybindings before proceeding
if ! invalid_keys=$(validate_keybindings); then
  source "$NUNCHUX_LIB_DIR/error_screens.sh"
  show_invalid_key_error "$invalid_keys"
fi

# Load enabled taskrunners
load_taskrunners

# Register all shortcuts after config is fully parsed
register_all_shortcuts() {
  local errors=""

  # Helper to register a single shortcut and collect errors
  _try_register() {
    local key="$1" item="$2" registry_key="$3"

    [[ -z "$key" ]] && return 0

    if ! validate_shortcut "$key" "$item" 2>/dev/null; then
      errors+="$key ($item) - "
      if ! is_valid_fzf_key "$key"; then
        errors+="invalid fzf key"
      else
        errors+="reserved key"
      fi
      errors+=$'\n'
    elif ! register_shortcut "$key" "$registry_key" 2>/dev/null; then
      errors+="$key ($item) - duplicate of ${SHORTCUT_REGISTRY[$key]}"$'\n'
    fi
  }

  local name
  for name in "${APP_ORDER[@]}"; do
    _try_register "${APP_SHORTCUT[$name]:-}" "app:$name" "$name"
  done

  for name in "${MENU_ORDER[@]}"; do
    _try_register "${MENU_SHORTCUT[$name]:-}" "menu:$name" "menu:$name"
  done

  for name in "${DIRBROWSE_ORDER[@]}"; do
    _try_register "${DIRBROWSE_SHORTCUT[$name]:-}" "dirbrowser:$name" "dirbrowser:$name"
  done

  unset -f _try_register

  if [[ -n "$errors" ]]; then
    source "$NUNCHUX_LIB_DIR/error_screens.sh"
    show_invalid_shortcut_error "$errors"
  fi
}

register_all_shortcuts

# Save config cache if we just parsed the config file
if [[ -n "${_NUNCHUX_SAVE_CONFIG_CACHE:-}" && -n "${_config_cache:-}" ]]; then
  save_config_cache "$_config_cache"
  unset _NUNCHUX_SAVE_CONFIG_CACHE
fi

# Launch an item by shortcut
launch_by_shortcut() {
  local item="$1"

  # Lazy-load nunchux-run before launching
  [[ -z "${NUNCHUX_RUN_LOADED:-}" ]] && { source "$NUNCHUX_BIN_DIR/nunchux-run"; NUNCHUX_RUN_LOADED=1; }

  if [[ "$item" == menu:* ]]; then
    # Enter submenu
    CURRENT_MENU="${item#menu:}"
    launch
  elif [[ "$item" == dirbrowser:* ]]; then
    # Enter dirbrowser
    launch_dirbrowse "${item#dirbrowser:}"
  else
    # Launch app with primary action
    local cmd="${APP_CMD[$item]:-}"
    [[ -z "$cmd" ]] && {
      echo "Unknown item: $item" >&2
      exit 1
    }
    app_launch "$item" "" "$cmd" "${APP_WIDTH[$item]:-}" "${APP_HEIGHT[$item]:-}" "${APP_ON_EXIT[$item]:-}"
  fi
}

# Check if any items are configured
has_config() {
  app_has_items || menu_has_items || dirbrowser_has_items || taskrunner_has_items
}

# Build combined menu
build_menu() {
  build_combined_menu "$CURRENT_MENU"
}

# Main launcher using fzf
launch() {
  # Build border label (includes cwd if configured)
  build_border_label "$CURRENT_MENU"

  # No config file at all? Offer to create one
  if ! has_config_file; then
    source "$NUNCHUX_LIB_DIR/onboarding.sh"
    show_no_config_popup
  fi

  local selection
  local script_path
  script_path=$(realpath "$0")

  # Build reload command with submenu context
  local reload_cmd="$script_path --menu"
  local primary_display="${PRIMARY_KEY^}"
  local secondary_display="${SECONDARY_KEY^}"

  # Check if config is empty (no apps, menus, dirbrowsers, or detected taskrunners)
  local config_is_empty=false
  if [[ ${#APP_ORDER[@]} -eq 0 && ${#MENU_ORDER[@]} -eq 0 && ${#DIRBROWSE_ORDER[@]} -eq 0 && ${#LOADED_TASKRUNNERS[@]} -eq 0 ]]; then
    config_is_empty=true
    # Lazy load onboarding module only when needed
    source "$NUNCHUX_LIB_DIR/onboarding.sh"
  fi

  # Build header
  local header=""
  if [[ "$config_is_empty" == "true" && -z "$CURRENT_MENU" ]]; then
    # Show helpful message for empty config
    header="No items configured. Edit $NUNCHUX_RC_FILE to add apps."
    header+=$'\n'"See docs: https://github.com/datamadsen/nunchux/blob/main/docs/configuration.md"
  elif [[ -n "$SHOW_SHORTCUTS" ]]; then
    header="$primary_display: $PRIMARY_ACTION | $secondary_display: $SECONDARY_ACTION | Ctrl-X: kill"
    [[ -n "$CURRENT_MENU" ]] && header="$header | Esc: back"
    # Add action shortcuts (same line)
    [[ -n "$POPUP_KEY" ]] && header="$header | ${POPUP_KEY^}: popup"
    [[ -n "$WINDOW_KEY" ]] && header="$header | ${WINDOW_KEY^}: window"
    [[ -n "$BACKGROUND_WINDOW_KEY" ]] && header="$header | ${BACKGROUND_WINDOW_KEY^}: bg"
    [[ -n "$PANE_RIGHT_KEY" ]] && header="$header | ${PANE_RIGHT_KEY^}: right"
    [[ -n "$PANE_LEFT_KEY" ]] && header="$header | ${PANE_LEFT_KEY^}: left"
    [[ -n "$PANE_ABOVE_KEY" ]] && header="$header | ${PANE_ABOVE_KEY^}: above"
    [[ -n "$PANE_BELOW_KEY" ]] && header="$header | ${PANE_BELOW_KEY^}: below"
    [[ -n "$ACTION_MENU_KEY" ]] && header="$header | ${ACTION_MENU_KEY^}: actions"
  fi

  if [[ -n "$CURRENT_MENU" ]]; then
    reload_cmd="$script_path --menu --submenu $CURRENT_MENU"
  fi

  # Cache settings
  local cache_file socket cache_ttl
  cache_ttl="$MENU_CACHE_TTL"

  if [[ -z "$CURRENT_MENU" ]]; then
    # Include cwd in cache key (items are directory-dependent)
    # Use parameter expansion instead of md5sum subprocess
    local cwd_safe="${PWD//\//_}"
    cache_file=$(cache_file "main-menu-$cwd_safe")
    socket=$(cache_socket "main-menu-$cwd_safe")
  else
    cache_file=$(cache_file "submenu" "$CURRENT_MENU")
    socket=$(cache_socket "submenu" "$CURRENT_MENU")
    cache_ttl="${SUBMENU_CACHE_TTL[$CURRENT_MENU]:-$MENU_CACHE_TTL}"
  fi

  # Build fzf options
  local fzf_opts
  build_fzf_opts fzf_opts "$header"
  fzf_opts+=(--bind="ctrl-x:reload($script_path --kill {3} >/dev/null 2>&1; $reload_cmd)")

  # Add shortcut bindings
  local shortcut_binds=()
  build_shortcut_binds shortcut_binds "$script_path"
  fzf_opts+=("${shortcut_binds[@]}")

  # Add ctrl-/ toggle for shortcuts display
  local toggle_cmd="$script_path"
  [[ -n "$CURRENT_MENU" ]] && toggle_cmd="$toggle_cmd --submenu $CURRENT_MENU"

  if [[ -n "$SHOW_SHORTCUTS" ]]; then
    fzf_opts+=(--bind="ctrl-/:become($toggle_cmd --hide-shortcuts)")
  else
    fzf_opts+=(--bind="ctrl-/:become($toggle_cmd --show-shortcuts)")
  fi

  # Run with cache if valid (but skip cache when showing shortcuts to avoid hot-swap issues)
  local fzf_exit=0
  local fzf_stderr="/tmp/nunchux-fzf-stderr-$$"
  if [[ "$config_is_empty" == "true" ]]; then
    # Empty config - show fallback menu (no caching)
    selection=$(build_empty_config_menu | fzf "${fzf_opts[@]}" 2>"$fzf_stderr") || fzf_exit=$?
  elif [[ -n "$SHOW_SHORTCUTS" ]]; then
    # When showing shortcuts, build fresh each time (no caching)
    selection=$(build_menu | add_shortcut_prefixes | fzf "${fzf_opts[@]}" 2>"$fzf_stderr") || fzf_exit=$?
  elif is_cache_valid "$cache_file" "$cache_ttl"; then
    # Clean up any leftover socket from previous invocation (e.g., if fzf was replaced via become())
    rm -f "$socket" 2>/dev/null || true
    refresh_cache "$cache_file" "$socket" build_menu &
    local refresh_pid=$!
    selection=$(cat "$cache_file" | fzf "${fzf_opts[@]}" --listen "$socket" 2>"$fzf_stderr") || fzf_exit=$?
    kill $refresh_pid 2>/dev/null || true
    rm -f "$socket" 2>/dev/null || true
  else
    selection=$(build_menu | tee "$cache_file" | fzf "${fzf_opts[@]}" 2>"$fzf_stderr") || fzf_exit=$?
  fi

  # If fzf failed (not just cancelled), show error
  if [[ $fzf_exit -ne 0 && $fzf_exit -ne 130 ]]; then
    echo ""
    echo "fzf exited with code $fzf_exit"
    if [[ -s "$fzf_stderr" ]]; then
      echo ""
      echo "Error output:"
      cat "$fzf_stderr"
    fi
    echo ""
    echo "fzf options: ${fzf_opts[*]}"
    echo ""
    echo "Press any key..."
    read -n 1 -s
    rm -f "$fzf_stderr"
    return 1
  fi
  rm -f "$fzf_stderr"

  if [[ -z "$selection" ]]; then
    return 0
  fi

  # Debug: log selection to temp file if NUNCHUX_DEBUG is set
  if [[ -n "${NUNCHUX_DEBUG:-}" ]]; then
    echo "=== $(date) ===" >>/tmp/nunchux-debug.log
    echo "Raw selection:" >>/tmp/nunchux-debug.log
    echo "$selection" | cat -A >>/tmp/nunchux-debug.log
    echo "PRIMARY_KEY=$PRIMARY_KEY" >>/tmp/nunchux-debug.log
    echo "SECONDARY_KEY=$SECONDARY_KEY" >>/tmp/nunchux-debug.log
  fi

  # Parse: first line is key pressed, rest is selection
  local key selected_line
  key=$(echo "$selection" | head -1)
  selected_line=$(echo "$selection" | tail -1)

  if [[ -n "${NUNCHUX_DEBUG:-}" ]]; then
    echo "Parsed key: '$key'" >>/tmp/nunchux-debug.log
    echo "Selected line: '$selected_line'" >>/tmp/nunchux-debug.log
  fi

  if [[ -z "$selected_line" ]]; then
    return 0
  fi

  # Handle esc key - go back or exit
  if [[ "$key" == "esc" ]]; then
    if [[ -n "$CURRENT_MENU" ]]; then
      # In a submenu - go back to main menu
      CURRENT_MENU=""
      launch
    fi
    # At main menu - just exit (return 0)
    return 0
  fi

  # Extract fields (tab-separated)
  # Format: display \t shortcut \t name \t cmd \t width \t height \t on_exit
  local name cmd width height on_exit
  name=$(echo "$selected_line" | cut -f3)
  cmd=$(echo "$selected_line" | cut -f4)
  width=$(echo "$selected_line" | cut -f5)
  height=$(echo "$selected_line" | cut -f6)
  on_exit=$(echo "$selected_line" | cut -f7)

  if [[ -z "$name" ]]; then
    return 0
  fi

  # Handle onboarding items (empty config fallback menu)
  # Only check if onboarding module was loaded (i.e., config was empty)
  if [[ $(type -t handle_onboarding_item) == "function" ]] && handle_onboarding_item "$name" "$cmd"; then
    return 0
  fi

  # Lazy-load nunchux-run before launching
  [[ -z "${NUNCHUX_RUN_LOADED:-}" ]] && { source "$NUNCHUX_BIN_DIR/nunchux-run"; NUNCHUX_RUN_LOADED=1; }

  # Try each module until one handles it
  local handled=false
  for mod in "${LOADED_MODULES[@]}"; do
    local launcher="${mod}_launch"
    if [[ $(type -t "$launcher") == "function" ]]; then
      local result=0
      "$launcher" "$name" "$key" "$cmd" "$width" "$height" "$on_exit" || result=$?

      if [[ $result -eq 0 ]]; then
        handled=true
        # If menu module handled it, relaunch with new context
        if [[ "$mod" == "menu" && -n "$CURRENT_MENU" ]]; then
          launch
        fi
        return 0
      elif [[ $result -eq 2 ]]; then
        handled=true
        # Special return: go back to main menu
        launch
        return 0
      fi
    fi
  done

  # If nothing handled the selection, show debug info
  if [[ "$handled" == "false" ]]; then
    echo ""
    echo "No module handled this selection:"
    echo "  name: $name"
    echo "  key: '$key' (expected: '$PRIMARY_KEY' or '$SECONDARY_KEY')"
    echo "  cmd: $cmd"
    echo ""
    echo "Press any key..."
    read -n 1 -s
  fi
}

# Show help
usage() {
  cat <<EOF
nunchux - Smart tmux app launcher

Usage: nunchux [options]

Options:
    (none)              Launch the app selector
    --list              List configured apps
    --shell-init [sh]   Output shell init code (bash/zsh/fish)
    --help              Show this help

Environment Inheritance:
    To inherit your shell environment (nvm, pyenv, etc.) in apps:

    Bash: Add to ~/.bashrc:
        eval "\$(nunchux --shell-init bash)"

    Zsh: Add to ~/.zshrc:
        eval "\$(nunchux --shell-init zsh)"

Configuration:
    Searches upward from current directory for .nunchuxrc
    Falls back to: $NUNCHUX_RC_FILE

    Run nunchux without a config to create one interactively.

Controls:
    Enter           Open in popup
    Ctrl-O          Open in window (or switch if running)
    Ctrl-X          Kill running app
    Escape          Cancel
EOF
}

# List apps
list_apps() {
  echo "Configured items:"
  echo ""
  for name in "${APP_ORDER[@]}"; do
    local cmd="${APP_CMD[$name]:-}"
    local desc="${APP_DESC[$name]:-}"
    if is_app_running "$name"; then
      printf "  %s %-12s %s\n" "$ICON_RUNNING" "$name" "$desc"
    else
      printf "  %s %-12s %s\n" "$ICON_STOPPED" "$name" "$desc"
    fi
  done
}

# Output shell initialization code for environment capture
shell_init() {
  local shell_type="${1:-bash}"

  cat <<'EOF'
# Nunchux shell integration - saves environment for inheritance
# This runs after each command, so apps launched via nunchux
# inherit your current shell environment (PATH, nvm, pyenv, etc.)
if [[ -n "$TMUX_PANE" ]]; then
    _nunchux_save_env() {
        env > "/tmp/nunchux-env-$TMUX_PANE" 2>/dev/null
    }
EOF

  case "$shell_type" in
  zsh)
    cat <<'EOF'
    precmd_functions+=(_nunchux_save_env)
fi
EOF
    ;;
  fish)
    # Fish has completely different syntax
    cat <<'EOF'
if set -q TMUX_PANE
    function _nunchux_save_env --on-event fish_postexec
        env > "/tmp/nunchux-env-$TMUX_PANE" 2>/dev/null
    end
end
EOF
    return
    ;;
  *) # bash and others
    cat <<'EOF'
    PROMPT_COMMAND="_nunchux_save_env${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
fi
EOF
    ;;
  esac
}

# Main
main() {
  case "${1:-}" in
  --shell-init)
    shift
    shell_init "${1:-bash}"
    exit 0
    ;;
  --kill)
    shift
    # Try app first, then taskrunner
    kill_app "$1" 2>/dev/null || taskrunner_kill "$1" 2>/dev/null || true
    ;;
  --menu)
    if [[ "${2:-}" == "--submenu" ]]; then
      CURRENT_MENU="$3"
    fi
    build_menu
    ;;
  --list)
    list_apps
    ;;
  --config)
    shift
    case "${1:-}" in
    menu_width) echo "$MENU_WIDTH" ;;
    menu_height) echo "$MENU_HEIGHT" ;;
    max_menu_width) echo "$MAX_MENU_WIDTH" ;;
    max_menu_height) echo "$MAX_MENU_HEIGHT" ;;
    popup_width) echo "$APP_POPUP_WIDTH" ;;
    popup_height) echo "$APP_POPUP_HEIGHT" ;;
    *)
      echo "Unknown config: $1" >&2
      exit 1
      ;;
    esac
    ;;
  --setup-wizard)
    # Run setup wizard directly (requires onboarding module)
    source "$NUNCHUX_LIB_DIR/onboarding.sh"
    show_setup_wizard
    exit 0
    ;;
  --popup)
    # Launch self in a tmux popup
    local script_path="$SCRIPT_DIR/nunchux"
    local dir
    dir=$(tmux display-message -p '#{pane_current_path}')

    # Use smaller popup if no config file exists
    local width height
    if ! has_config_file; then
      width=52
      height=13
    else
      width="${MAX_MENU_WIDTH:-$MENU_WIDTH}"
      height="${MAX_MENU_HEIGHT:-$MENU_HEIGHT}"
    fi

    exec tmux display-popup -E -B -d "$dir" -w "$width" -h "$height" "$script_path"
    ;;
  --submenu)
    shift
    CURRENT_MENU="$1"
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --show-shortcuts)
    SHOW_SHORTCUTS=1
    export SHOW_SHORTCUTS
    shift
    if [[ "${1:-}" == "--submenu" ]]; then
      CURRENT_MENU="$2"
    fi
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --hide-shortcuts)
    SHOW_SHORTCUTS=""
    shift
    if [[ "${1:-}" == "--submenu" ]]; then
      CURRENT_MENU="$2"
    fi
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  --launch-shortcut)
    shift
    launch_by_shortcut "$1"
    ;;
  --help | -h | help)
    usage
    ;;
  "")
    if ! launch 2>&1; then
      echo "Press any key to close..."
      read -n 1
    fi
    ;;
  *)
    echo "Unknown option: $1" >&2
    usage >&2
    exit 1
    ;;
  esac
}

main "$@"

# vim: ft=bash ts=2 sw=2 et
