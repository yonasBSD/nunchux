# Nunchux Configuration
#
# Copy to: ~/.config/nunchux/config
# Fallback: ~/.nunchuxrc

[settings]
icon_running = ●
icon_stopped = ○
menu_width = 60%
menu_height = 50%
popup_width = 90%
popup_height = 90%
just_enabled = true
npm_enabled = true
fzf_prompt =
fzf_pointer = ▶
fzf_border = rounded
fzf_border_label =  nunchux
fzf_colors = fg+:white:bold,bg+:-1,hl:cyan,hl+:cyan:bold,pointer:cyan,marker:green,header:gray,border:gray
cache_ttl = 60

# A few words about cache_ttl
# ----------------------------
# Nunchux caches menus to make them open instantly. When you open a menu,
# you see the cached version right away while fresh data loads in the background.
# Once ready, the menu hot-swaps to show updated info.
#
# cache_ttl controls how long (in seconds) a cache is considered "fresh enough"
# to show instantly. After this time, the menu builds from scratch (with the
# nice streaming effect where items appear one by one).
#
# - In [settings]: sets the default for main menu and all submenus (default: 60)
# - In a submenu like [system]: overrides just that submenu
# - In a directory browser: controls that browser (default: 300 for dir browsers)
#
# Set to 0 to disable caching entirely for that menu.

# exclude_patterns (for directory browsers)
# ------------------------------------------
# Comma-separated list of patterns to exclude from directory browsers.
# - Patterns starting with * are filename globs (e.g., *.log, *.db)
# - Other patterns exclude both directories and files with that name
#
# Default excludes common non-text files: .git, node_modules, cache dirs,
# databases, images, fonts, lock files, etc.
#
# Example: exclude_patterns = .git, node_modules, *.log, *.tmp, build

# Apps
# Each section defines an app. The section name becomes the window name.
#
# Available options:
#   cmd           = command to run (required)
#   desc          = description shown in menu
#   width         = popup width (e.g., 80 or 80%)
#   height        = popup height
#   status        = shell command for dynamic status
#   status_script = path to script for complex status
#   on_exit       = command to run after app exits
#
# Variables available in cmd and on_exit:
#   {pane_id}     = parent tmux pane ID
#   {tmp}         = fresh temp file path
#   {dir}         = starting directory
#
# Submenus:
#   Use [parent/child] section names to create submenus.
#   The parent appears in the main menu; selecting it opens the submenu.

[btop]
cmd = btop
status = load=$(cut -d' ' -f1 /proc/loadavg); \
         ram=$(awk '/MemAvailable/{printf "%.0f", $2/1024/1024}' /proc/meminfo); \
         disk=$(df /home --output=avail 2>/dev/null | tail -1 | awk '{printf "%.0f", $1/1024/1024}'); \
         echo "load: $load | ram: ${ram}GB free | /home: ${disk}GB free"

[htop]
cmd = htop
desc = Process viewer

[git]
cmd = lazygit
status = n=$(git status -s 2>/dev/null | wc -l | tr -d ' '); [[ $n -gt 0 ]] && echo "($n changed)"

[docker]
cmd = lazydocker
status = n=$(docker ps -q 2>/dev/null | wc -l | tr -d ' '); [[ $n -gt 0 ]] && echo "($n running)"

# [k9s]
# cmd = k9s
# status = ctx=$(kubectl config current-context 2>/dev/null); [[ -n "$ctx" ]] && echo "($ctx)"

# [files]
# # yazi doesn't work directly in tmux popups due to terminal passthrough issues.
# # Workaround: wrap in nvim terminal. See https://github.com/sxyazi/yazi/issues/2308
# cmd = nvim --clean -c 'set laststatus=0 cmdheight=0 noshowmode noruler signcolumn=no nonumber' -c 'terminal yazi --cwd-file={tmp}' -c 'startinsert' -c 'autocmd TermClose * qa!'
# desc = File manager
# # Only cd if pane is at a shell prompt (not in vim, etc.)
# on_exit = cwd=$(cat {tmp} 2>/dev/null); \
#   if [[ -d "$cwd" ]]; then \
#     cmd=$(tmux display-message -t {pane_id} -p '#{pane_current_command}'); \
#     [[ "$cmd" =~ ^(bash|zsh|fish|sh)$ ]] && tmux send-keys -t {pane_id} "cd \"$cwd\"" Enter; \
#   fi; \
#   rm -f {tmp}

# [notes]
# cmd = nvim ~/notes
# width = 80
# height = 60
# status = mins=$(( ($(date +%s) - $(stat -c %Y ~/notes 2>/dev/null || echo 0)) / 60 )); [[ $mins -lt 60 ]] && echo "(${mins}m ago)" || echo "($(($mins/60))h ago)"

# [todos]
# cmd = nvim ~/todos.md
# width = 70
# height = 50
# status = n=$(wc -l < ~/todos.md 2>/dev/null || echo 0); echo "($n lines)"

# System submenu example
# Submenus use [parent/child] naming. The parent shows in the main menu,
# selecting it opens the submenu with all its children.
#
# Prerequisites for this example:
#   btop       - System monitor          (https://github.com/aristocratos/btop)
#   impala     - WiFi manager TUI        (https://github.com/pythops/impala)
#   bluetuith  - Bluetooth manager TUI   (https://github.com/darkhz/bluetuith)
#   bandwhich  - Bandwidth by process    (https://github.com/imsnif/bandwhich)
#   duf        - Disk usage overview     (https://github.com/muesli/duf)
#   ncdu       - Disk usage analyzer     (https://dev.yorhel.nl/ncdu)
#
# The [system] section (without /child) defines the submenu's status line.

# [system]
# status = load=$(cut -d' ' -f1 /proc/loadavg); \
#          ram=$(awk '/MemAvailable/{printf "%.0f", $2/1024/1024}' /proc/meminfo); \
#          echo "load: $load | ${ram}GB free"
#
# [system/btop]
# cmd = btop
# desc = Task manager
#
# [system/impala]
# cmd = impala
# desc = WiFi manager
#
# [system/bluetuith]
# cmd = bluetuith
# desc = Bluetooth manager
#
# [system/bandwhich]
# cmd = sudo bandwhich
# desc = Bandwidth by process
#
# [system/duf]
# cmd = duf -only local | less -R
# desc = Disk usage overview
# width = 60
# height = 30
#
# [system/ncdu]
# cmd = ncdu
# desc = Disk usage analyzer

# Directory browser
# Instead of cmd, use "directory" to create a file browser.
# Selected files open in $VISUAL, $EDITOR, or nvim (in that order).
#
# Available options:
#   directory      = path to browse (required, replaces cmd)
#   depth          = how many levels deep to search (default: 1)
#   sort           = sorting mode: "modified", "modified-folder", or "alphabetical"
#   sort_direction = "ascending" or "descending" (default: descending)
#   cache_ttl      = cache duration in seconds (default: 300)
#   glob           = filter files by pattern (e.g., "*.conf")
#   width          = popup width
#   height         = popup height
#
# Sort modes:
#   modified        = newest files first
#   modified-folder = folders grouped by most recent file, then files by recency
#   alphabetical    = sorted by folder/filename

# [configs]
# directory = ~/.config
# depth = 2
# sort = modified-folder
# cache_ttl = 300
